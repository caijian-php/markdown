1. 什么是IPC 进程间通信？

   ```markdown
   进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息
   ```

   

   

2. 管道的数据结构？

```markdown
 在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。
```



3. 管道的实现机制？

```
管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。
管道的一端连接一个进程的输出。这个进程会向管道中放入信息。
管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。
一个缓冲区不需要很大一般为4K大小，它被设计成为环形的数据结构，以便管道可以被循环利用。
当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。
当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。
当所有进程都终结的时候，管道也自动消失。
```



4. 什么是单向通信？什么是双向通信？

```markdown
单向通信是指通信的信道是单向的，发送端与接收端也是固定的，即发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息。
```

```markdown
半双向通信是指一种切换方向的单向通信。在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输。
```

```
双向通信是指允许数据同时在两个方向上传输，即通信的双方可以同时发送和接收数据。
```

```markdown
管道pipe是半双工的，pipe两次才能实现全双工。
```




5. Linux上实现双向进程间通信管道(socketpair)？

```
TODO
```



6. 什么是匿名管道？什么是有名管道



7. 匿名管道和有名管道的区别与联系

```markdown
匿名管道由pipe函数创建或打开
命名管道由mkfifo函数创建，打开用open.
FIFO与PIPE的区别在它们创建与打开的方式不同，一旦这些工作完后，它们语义相同。
```



8. 匿名管道的限制

```markdown
匿名管道的一个限制就是只能在具有共同祖先的进程间通信

命名管道（FIFO）：如果我们想在不相关的进程之间切换数据，可以使用FIFO文件来做这项工作
```



9. 管道进行实际的内存复制工作的条件

```markdown
写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：
内存中有足够的空间可容纳所有要写入的数据；
内存没有被读程序锁定。

如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。
否则，写入进程就休眠在 VFS 索引
节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。

写入进程实际处于可中断的等待状态，当内
存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内
存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。

当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。
```

```
管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖文件或管道的打开模式。
反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。
```

```markdown
因为管道的实现涉及很多文件的操作,因此,当读者学完有关文件系统的内容后来读pipe.c中的代码，你会觉得并不难理解。
```



10. 文件或管道的打开规则？



11. 有名管道FIFO的打开规则？

```markdown
有名管道比管道多了一个打开操作：open。

FIFO的打开规则：

如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。

简言之，当写则可读，非写则堵塞读。

如果当前打开操作是为写而打开FIFO时，若已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。

简言之，当读则可写，非读则堵。
```



12. 有名管道的读写规则？

```markdown
从FIFO中读取数据：

约定：如果一个进程 为了从FIFO中读取数据 而阻塞打开FIFO，那么称该进程内的读操作为 设置了阻塞标志的读操作。

如果有进程 写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。

对于 设置了阻塞标志的读操作，造成阻塞的原因有两种：
当前FIFO内有数据，但有其它进程在读这些数据；
另外就是FIFO内没有数据。
解阻塞的原因则是FIFO中有新的数据写入，不论新写入数据量的大小，也不论读操作请求多少数据量。

读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。

如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。
注：如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。
```

```markdown
向FIFO中写入数据：

约定：如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。

对于设置了阻塞标志的写操作：

当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。

当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。
对于没有设置阻塞标志的写操作：

当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。

当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写；
```



































